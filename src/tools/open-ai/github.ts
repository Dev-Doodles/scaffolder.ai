import { tool, Tool } from '@openai/agents';
import { ToolProvider } from '../../interfaces/index.js';
import { ToolResponse } from '../response.js';
import {
  DeleteRepositorySchema,
  DeleteRepositorySpec,
  LocalRepoSpec,
  LocalRepoSpecSchema,
  RepositorySchema,
  RepositorySpec,
} from '../schema.js';
import { GitHubClient } from '../../utils/index.js';
import { Injectable } from '@nestjs/common';

interface CreateRepositoryOutput {
  repositoryUrl: string;
}

const DEFAULT_COMMIT_MESSAGE =
  'feat: initial commit generated by scaffolder AI';

@Injectable()
export class GithubTool extends ToolProvider<Tool> {
  constructor(private readonly client: GitHubClient) {
    super();
  }

  async createRepository(
    spec: RepositorySpec,
  ): Promise<ToolResponse<CreateRepositoryOutput>> {
    try {
      const { name, description, visibility, hasIssues, hasProjects, hasWiki } =
        spec;
      const repositoryUrl = await this.client.createRepository({
        name,
        description,
        visibility,
        hasIssues,
        hasProjects,
        hasWiki,
      });

      return {
        body: { repositoryUrl },
        status: 'success',
      };
    } catch (error) {
      this.handleError(
        error,
        `Failed to create GitHub repository: ${spec.name}`,
        'createRepository',
      );
    }
  }

  async addRemoteOrigin({
    localPath,
    repositoryUrl,
  }: LocalRepoSpec): Promise<ToolResponse<void>> {
    try {
      await this.client.addremote(localPath, repositoryUrl);
      return { status: 'success' };
    } catch (error) {
      this.handleError(
        error,
        `Failed to add remote origin: ${repositoryUrl} to local path: ${localPath}`,
        'addRemoteOrigin',
      );
    }
  }

  async checkinFiles({
    localPath,
    message,
  }: LocalRepoSpec): Promise<ToolResponse<void>> {
    try {
      await this.client.commitAndPush(
        localPath,
        message ?? DEFAULT_COMMIT_MESSAGE,
      );
      return { status: 'success' };
    } catch (error) {
      this.handleError(
        error,
        `Failed to commit and push files: localPath=${localPath}, message=${message}`,
        'checkinFiles',
      );
    }
  }

  async deleteRepository({
    owner,
    name,
  }: DeleteRepositorySpec): Promise<ToolResponse<void>> {
    try {
      await this.client.deleteRepository(name, owner);
      return { status: 'success' };
    } catch (error) {
      this.handleError(
        error,
        `Failed to delete GitHub repository: ${owner}/${name}`,
        'deleteRepository',
      );
    }
  }

  getTools(): Tool[] {
    return [
      tool({
        name: 'create_github_repository',
        description: 'A tool to create a new GitHub repository.',
        parameters: RepositorySchema,
        strict: true,
        execute: (input: RepositorySpec) => this.createRepository(input),
      }),
      tool({
        name: 'add_remote_origin',
        description:
          'A tool to initialise git in local folder and add a remote origin to it.',
        parameters: LocalRepoSpecSchema,
        strict: true,
        execute: (input: LocalRepoSpec) => this.addRemoteOrigin(input),
      }),
      tool({
        name: 'checkin_files',
        description:
          'A tool to commit and push files from a local git repository to its remote origin.',
        parameters: LocalRepoSpecSchema,
        strict: true,
        execute: (input: LocalRepoSpec) => this.checkinFiles(input),
      }),
      tool({
        name: 'delete_github_repository',
        description:
          'A tool to delete a GitHub repository. Requires repository name and owner is defaulted to the organisation if not provided.',
        parameters: DeleteRepositorySchema,
        strict: true,
        execute: (input: DeleteRepositorySpec) => this.deleteRepository(input),
      }),
    ];
  }
}
