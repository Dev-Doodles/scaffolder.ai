import { describe, it, expect, vi, beforeEach, Mock } from 'vitest';
import { GithubTool } from './github.js';
import { GitHubClient } from '../../utils/index.js';
import { ToolError } from '../../errors/index.js';

vi.mock('@openai/agents', () => ({
  tool: vi.fn((config) => ({
    name: config.name,
    description: config.description,
    parameters: config.parameters,
    strict: config.strict,
    invoke: async (input: unknown) => config.execute(input),
  })),
}));

describe('GithubTool', () => {
  let githubTool: GithubTool;
  let mockClient: {
    createRepository: Mock;
    addremote: Mock;
    commitAndPush: Mock;
    deleteRepository: Mock;
  };

  beforeEach(() => {
    mockClient = {
      createRepository: vi.fn(),
      addremote: vi.fn(),
      commitAndPush: vi.fn(),
      deleteRepository: vi.fn(),
    };
    githubTool = new GithubTool(mockClient as unknown as GitHubClient);
  });

  describe('createRepository', () => {
    const validSpec = {
      name: 'test-repo',
      description: 'A test repository',
      visibility: true,
      hasIssues: true,
      hasProjects: false,
      hasWiki: false,
    };

    it('should create a repository successfully', async () => {
      const expectedUrl = 'git@github.com:org/test-repo.git';
      mockClient.createRepository.mockResolvedValue(expectedUrl);

      const result = await githubTool.createRepository(validSpec);

      expect(result).toEqual({
        body: { repositoryUrl: expectedUrl },
        status: 'success',
      });
      expect(mockClient.createRepository).toHaveBeenCalledWith({
        name: validSpec.name,
        description: validSpec.description,
        visibility: validSpec.visibility,
        hasIssues: validSpec.hasIssues,
        hasProjects: validSpec.hasProjects,
        hasWiki: validSpec.hasWiki,
      });
    });

    it('should throw ToolError when repository creation fails', async () => {
      const error = new Error('API rate limit exceeded');
      mockClient.createRepository.mockRejectedValue(error);

      await expect(githubTool.createRepository(validSpec)).rejects.toThrow(
        ToolError,
      );
    });
  });

  describe('addRemoteOrigin', () => {
    const validSpec = {
      localPath: '/tmp/scaffolder/test-repo',
      repositoryUrl: 'git@github.com:org/test-repo.git',
      remoteName: 'origin',
      message: 'chore(init): initial commit',
    };

    it('should add remote origin successfully', async () => {
      mockClient.addremote.mockResolvedValue(undefined);

      const result = await githubTool.addRemoteOrigin(validSpec);

      expect(result).toEqual({ status: 'success' });
      expect(mockClient.addremote).toHaveBeenCalledWith(
        validSpec.localPath,
        validSpec.repositoryUrl,
      );
    });

    it('should throw ToolError when adding remote origin fails', async () => {
      const error = new Error('Invalid repository path');
      mockClient.addremote.mockRejectedValue(error);

      await expect(githubTool.addRemoteOrigin(validSpec)).rejects.toThrow(
        ToolError,
      );
    });
  });

  describe('checkinFiles', () => {
    const validSpec = {
      localPath: '/tmp/scaffolder/test-repo',
      repositoryUrl: 'git@github.com:org/test-repo.git',
      remoteName: 'origin',
      message: 'feat: add new feature',
    };

    it('should commit and push files successfully', async () => {
      mockClient.commitAndPush.mockResolvedValue(undefined);

      const result = await githubTool.checkinFiles(validSpec);

      expect(result).toEqual({ status: 'success' });
      expect(mockClient.commitAndPush).toHaveBeenCalledWith(
        validSpec.localPath,
        validSpec.message,
      );
    });

    it('should use default commit message when not provided', async () => {
      mockClient.commitAndPush.mockResolvedValue(undefined);
      const specWithoutMessage = {
        localPath: '/tmp/scaffolder/test-repo',
        repositoryUrl: 'git@github.com:org/test-repo.git',
        remoteName: 'origin',
      };

      await githubTool.checkinFiles(specWithoutMessage);

      expect(mockClient.commitAndPush).toHaveBeenCalledWith(
        specWithoutMessage.localPath,
        'feat: initial commit generated by scaffolder AI',
      );
    });

    it('should throw ToolError when commit and push fails', async () => {
      const error = new Error('Push rejected');
      mockClient.commitAndPush.mockRejectedValue(error);

      await expect(githubTool.checkinFiles(validSpec)).rejects.toThrow(
        ToolError,
      );
    });
  });

  describe('deleteRepository', () => {
    const validSpec = {
      name: 'test-repo',
      owner: 'test-org',
    };

    it('should delete repository successfully', async () => {
      mockClient.deleteRepository.mockResolvedValue(undefined);

      const result = await githubTool.deleteRepository(validSpec);

      expect(result).toEqual({ status: 'success' });
      expect(mockClient.deleteRepository).toHaveBeenCalledWith(
        validSpec.name,
        validSpec.owner,
      );
    });

    it('should throw ToolError when repository deletion fails', async () => {
      const error = new Error('Repository not found');
      mockClient.deleteRepository.mockRejectedValue(error);

      await expect(githubTool.deleteRepository(validSpec)).rejects.toThrow(
        ToolError,
      );
    });
  });

  describe('getTools', () => {
    it('should return an array of 4 tools', () => {
      const tools = githubTool.getTools();

      expect(tools).toHaveLength(4);
    });

    it('should include create_github_repository tool', () => {
      const tools = githubTool.getTools();
      const createTool = tools.find(
        (t) => t.name === 'create_github_repository',
      );

      expect(createTool).toBeDefined();
      expect(createTool?.name).toBe('create_github_repository');
    });

    it('should include add_remote_origin tool', () => {
      const tools = githubTool.getTools();
      const addRemoteTool = tools.find((t) => t.name === 'add_remote_origin');

      expect(addRemoteTool).toBeDefined();
      expect(addRemoteTool?.name).toBe('add_remote_origin');
    });

    it('should include checkin_files tool', () => {
      const tools = githubTool.getTools();
      const checkinTool = tools.find((t) => t.name === 'checkin_files');

      expect(checkinTool).toBeDefined();
      expect(checkinTool?.name).toBe('checkin_files');
    });

    it('should include delete_github_repository tool', () => {
      const tools = githubTool.getTools();
      const deleteTool = tools.find(
        (t) => t.name === 'delete_github_repository',
      );

      expect(deleteTool).toBeDefined();
      expect(deleteTool?.name).toBe('delete_github_repository');
    });

    describe('execute callbacks', () => {
      it('should execute createRepository when create_github_repository tool is invoked', async () => {
        const expectedUrl = 'git@github.com:org/test-repo.git';
        mockClient.createRepository.mockResolvedValue(expectedUrl);

        const tools = githubTool.getTools();
        const createTool = tools.find(
          (t) => t.name === 'create_github_repository',
        );

        const result = await (createTool as any).invoke({
          name: 'test-repo',
          description: 'Test',
          visibility: true,
          hasIssues: true,
          hasProjects: false,
          hasWiki: false,
        });

        expect(result.status).toBe('success');
        expect(mockClient.createRepository).toHaveBeenCalled();
      });

      it('should execute addRemoteOrigin when add_remote_origin tool is invoked', async () => {
        mockClient.addremote.mockResolvedValue(undefined);

        const tools = githubTool.getTools();
        const addRemoteTool = tools.find((t) => t.name === 'add_remote_origin');

        const result = await (addRemoteTool as any).invoke({
          localPath: '/tmp/test',
          repositoryUrl: 'git@github.com:org/repo.git',
        });

        expect(result.status).toBe('success');
        expect(mockClient.addremote).toHaveBeenCalled();
      });

      it('should execute checkinFiles when checkin_files tool is invoked', async () => {
        mockClient.commitAndPush.mockResolvedValue(undefined);

        const tools = githubTool.getTools();
        const checkinTool = tools.find((t) => t.name === 'checkin_files');

        const result = await (checkinTool as any).invoke({
          localPath: '/tmp/test',
          repositoryUrl: 'git@github.com:org/repo.git',
          message: 'test commit',
        });

        expect(result.status).toBe('success');
        expect(mockClient.commitAndPush).toHaveBeenCalled();
      });

      it('should execute deleteRepository when delete_github_repository tool is invoked', async () => {
        mockClient.deleteRepository.mockResolvedValue(undefined);

        const tools = githubTool.getTools();
        const deleteTool = tools.find(
          (t) => t.name === 'delete_github_repository',
        );

        const result = await (deleteTool as any).invoke({
          name: 'test-repo',
          owner: 'test-org',
        });

        expect(result.status).toBe('success');
        expect(mockClient.deleteRepository).toHaveBeenCalled();
      });
    });
  });
});
